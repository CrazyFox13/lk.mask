<?php

namespace App\Models;

// use Illuminate\Contracts\Auth\MustVerifyEmail;
use App\Helpers\Mutator;
use App\Mail\EmployeeInvitation;
use App\Models\Company;
use App\Models\CompanyType;
use App\Services\CompanyRatingCalculator;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Mail;
use Laravel\Sanctum\HasApiTokens;

class User extends Authenticatable
{
    use HasApiTokens, HasFactory, Notifiable, SoftDeletes;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'company_id',
        'company_role',
        'name',
        'surname',
        'email',
        'phone',
        'password',
        'geo_city_id',
        'city_id',
        'region_id',
        'email_verified_at',
        'phone_verified_at',
        'comment'
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array<int, string>
     */
    protected $hidden = [
        'password',
        'remember_token',
        'phone_code',
        'email_code',
        'reset_hash'
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
        'email_code_sent_at' => 'datetime',
        'phone_verified_at' => 'datetime',
        'phone_code_sent_at' => 'datetime',
        'last_online_datetime' => 'datetime',
    ];

    protected $appends = ['allowed_to_show_contacts'];

    const ANONYMOUS_CONTACTS_ACCESS_DAYS = 7;

    const PHONE_CODE_SENDING_TIMEOUT = 30;

    const USER_TYPES = ['user', 'moderator', 'admin'];

    const COMPANY_ROLES = ['employee', 'boss'];

    const PUBLIC_FIELDS = ['users.id', 'users.email', 'users.phone', 'users.rating', 'users.name', 'users.surname', 'users.avatar', 'users.company_id', 'users.company_role', 'users.last_online_datetime', 'users.city_id', 'users.geo_city_id', 'users.deleted_at'];

    const SHOW_FOR_GUESTS = [
        'id',
        'company_id',
        'name',
        'surname',
        'avatar',
        'rating',
        'last_online_datetime',
        'city_id',
        'region_id'
    ];

    const RESERVED_PHONES = [
        '79653684111',
        '79262563403',
        '79515551144',
        '79515551133',
        '79515551122',
        '79515551111',
        '79637296764',
        '79262563403',
        '79687852240',
        '79515551155',
        '79263331548',
        '79152458864',
        '79257841256',
        '79263218596',
        '79254169375',
        '79852634586',
        '79636589426'
    ];

    public static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub

        self::creating(function (User $user) {
            $user->silence_from = 22;
            $user->silence_to = 9;
        });

        self::created(function (User $user) {
            NotificationType::attachNotifications($user);
            
            // Автоматически создаем компанию для обычных пользователей (не админов и не модераторов)
            // Проверяем, что пользователь не админ и не модератор (type === 'user' или type === null)
            $userType = $user->type ?? 'user';
            $isRegularUser = ($userType === self::USER_TYPES[0] || is_null($user->type));
            
            if ($isRegularUser && is_null($user->company_id)) {
                $customerType = CompanyType::where('title', 'Заказчик')->first();
                if ($customerType) {
                    $company = new Company([
                        'company_type_id' => $customerType->id,
                        'moderation_status' => Company::MODERATION_STATUSES['DRAFT'],
                    ]);
                    $company->save();
                    
                    // Связываем пользователя с компанией как босса
                    $user->company_id = $company->id;
                    $user->company_role = self::COMPANY_ROLES[1]; // 'boss'
                    $user->save();
                }
            }
        });


        self::softDeleted(function (User $user) {
            $user->prepareDeleting(request()->get('user_id'));

            $now = Carbon::now()->format("Y-m-d_H:i:s");
            $user->phone = "deleted_" . $now . "_" . $user->phone;
            $user->email = "deleted_" . $now . "_" . $user->email;
            $user->save();
        });

        self::forceDeleted(function (User $user) {
            $user->prepareDeleting();
        });
    }

    /**
     * Relations
     */

    public function device()
    {
        return $this->hasOne(AppDevice::class, 'user_id');
    }

    public function chats()
    {
        return $this->belongsToMany(Chat::class)->withPivot(["role", "last_seen_at", "muted_at", "blocked_at"])->using(ChatUser::class);
    }

    public function region()
    {
        return $this->belongsTo(Region::class);
    }

    public function city()
    {
        return $this->belongsTo(GeoCity::class, 'geo_city_id');
    }

    public function favoriteOrderPivots()
    {
        return $this->hasMany(FavoriteOrder::class);
    }

    public function orders()
    {
        return $this->hasMany(Order::class);
    }

    public function claims()
    {
        return $this->hasMany(Claim::class);
    }

    public function activeOrders()
    {
        return $this->orders()->active();
    }

    public function finishedOrders()
    {
        return $this->orders()->finished();
    }

    public function completedOrders()
    {
        return $this->orders()->completed();
    }

    public function lastOrder()
    {
        return $this->hasOne(Order::class)->orderBy("created_at", "desc");
    }

    public function recommendations()
    {
        return $this->hasMany(Recommendation::class, 'target_user_id');
    }

    public function approvedRecommendations()
    {
        return $this->recommendations()->approved();
    }

    public function reports()
    {
        return $this->hasMany(Report::class, 'target_user_id');
    }

    public function activeReports()
    {
        // todo change method to confirmedReports -> ask ios/android to change key
        return $this->reports()->confirmed();
    }

    public function logs()
    {
        return $this->hasMany(UserLog::class);
    }

    /**
     * Ручные PUSH рассылки
     */
    public function pushNotifications()
    {
        return $this->belongsToMany(PushNotification::class)->withPivot('schedule_id')->withPivot('sent_at');
    }

    /**
     * Конкретные уведомления (ручные+автоматические)
     */
    public function companyNotifications()
    {
        return $this->hasMany(CompanyNotification::class);
    }

    public function company()
    {
        return $this->belongsTo(Company::class);
    }

    public function favorites()
    {
        return $this->hasMany(FavoriteUser::class, 'target_user_id');
    }

    public function orderFilters()
    {
        return $this->hasMany(OrderFilter::class);
    }

    public function notificationTypes()
    {
        return $this->belongsToMany(NotificationType::class)->withPivot('way', 'active');
    }

    public function notificationTypePivots()
    {
        return $this->hasMany(NotificationTypeUser::class);
    }

    public function subscribedVehicles()
    {
        return $this->belongsToMany(VehicleType::class, 'subscribed_vehicles');
    }

    public function subscribedCities()
    {
        return $this->belongsToMany(GeoCity::class, 'subscribed_geos');
    }

    public function orderOffsets(): HasMany
    {
        return $this->hasMany(OrderOffer::class);
    }

    /**
     * Scopes
     */

    public function scopeStaff($query)
    {
        return $query->where("company_role", "!=", User::COMPANY_ROLES[1]);
    }

    public function scopeBoss($query)
    {
        return $query->where("company_role", "=", User::COMPANY_ROLES[1]);
    }

    public function scopeAdmin($q)
    {
        return $q->where("type", self::USER_TYPES[2]);
    }

    public function scopeModerator($q)
    {
        return $q->where("type", self::USER_TYPES[1]);
    }

    public function scopeUser($q)
    {
        return $q->where("type", self::USER_TYPES[0]);
    }

    public function scopeOnline($q)
    {
        return $q->where('last_online_datetime', '>', Carbon::now()->subMinutes(3));
    }

    public function scopeSearch($q, $search)
    {
        return $q->where(function ($q) use ($search) {
            $q->where("name", "like", "%$search%")
                ->orWhere("surname", "like", "%$search%")
                ->orWhere("email", "like", "%$search%")
                ->orWhere("phone", "like", "%$search%");
        });
    }

    public function scopeFavorite(Builder $query): Builder
    {
        return $query->whereHas('favorites', function (Builder $query) {
            $query->where('favorite_users.user_id', auth()->id());
        });
    }

    public function scopeNotificationEnabled(Builder $query, string $key, string $way): Builder
    {
        return $query->whereHas("notificationTypes", function ($q) use ($key, $way) {
            $q->where("notification_types.key", '=', $key)
                ->where("notification_type_user.way", $way)
                ->where("notification_type_user.active", true);
        });
    }

    public function scopeNotInCompany(Builder $query, int|null $companyId): Builder
    {
        if (!$companyId) {
            return $query;
        }

        return $query->whereDoesntHave("company", function ($q) use ($companyId) {
            $q->where("company_id", "=", $companyId);
        });
    }

    public function scopeWithoutVehicleSubscribes($q)
    {
        return $q->doesntHave("subscribedVehicles");
    }

    public function scopeSubscribedOnVehicles($q, $vehList)
    {
        return $q->whereHas("subscribedVehicles", function ($q) use ($vehList) {
            $q->whereIn("vehicle_types.id", $vehList);
        });
    }

    public function scopeFiltered(Builder $query, array $filters): Builder
    {
        if (isset($filters['search'])) {
            $query = $query->search($filters['search']);
        }

        switch ($filters['status'] ?? null) {
            case 'without_company':
                $query = $query->whereNull("company_id");
                break;
            case 'boss':
                $query = $query->boss();
                break;
            case 'staff':
                $query = $query->staff();
                break;
        }

        if ($lastDevices = ($filters['devices'] ?? null)) {
            if (is_string($lastDevices)) {
                $lastDevices = explode(",", $lastDevices);
            }
            $query = $query->whereIn("last_device", $lastDevices);
        }

        if ($filters['without_profile'] ?? null) {
            $query = $query->whereNull("email_verified_at");
        }

        if ($filters['without_vehicle_subscribe'] ?? null) {
            $query = $query->doesntHave("subscribedVehicles");
        }

        if ($filters['without_filters'] ?? null) {
            $query = $query->doesntHave("orderFilters");
        }

        if ($filters["company_status"] ?? null) {
            $status = $filters["company_status"];
            $query = $query->whereHas("company", function ($q) use ($status) {
                $q->where("moderation_status", "=", $status);
            });
        }

        if ($companyTypesId = ($filters['company_types_id'] ?? null)) {
            if (is_string($companyTypesId)) {
                $companyTypesId = explode(",", $companyTypesId);
            }
            $query = $query->whereHas("company", function ($q) use ($companyTypesId) {
                $q->whereIn("company_type_id", $companyTypesId);
            });
        }

        if ($filters["subscribed_personal_push"] ?? null) {
            $query->notificationEnabled("personal", "push");
        }
        if ($filters["subscribed_personal_email"] ?? null) {
            $query->notificationEnabled("personal", "email");
        }

        return $query;
    }

    public function scopeWithConfirmedEmail($q)
    {
        return $q->whereNotNull("email_verified_at");
    }

    /**
     * Accessors, Mutators
     */

    public function getIsFavoriteAttribute()
    {
        return $this->inFavorite();
    }

    public function getPhoneAttribute($value)
    {
        /** @var User|null $user */
        $user = auth('sanctum')->user();
        if ($user && $user->id == $this->id) return $value;
        if ($user && $user->allowedToShowContacts()) {
            if (!$value) return null;
            return Mutator::numberToDigits($value);
        }
        return "* * * * * *";
    }

    public function getEmailAttribute($value)
    {
        /** @var User|null $user */
        $user = auth('sanctum')->user();
        if ($user && $user->id == $this->id) return $value;
        if ($user && $user->allowedToShowContacts()) return $value;
        return '* * * * * *';
    }

    public function getAvatarAttribute($value)
    {
        if (auth('sanctum')->guest()) return null;
        if ($this->isEmployee() && $company = $this->company) {
            return $company->boss?->avatar;
        }
        return $value;
    }

    public function getRatingAttribute($value)
    {
        return round($value * 10) / 10;
    }

    public function getNameAttribute($value)
    {
        if (auth('sanctum')->guest()) return "Имя";
        return $value;
    }

    public function getSurnameAttribute($value)
    {
        if (auth('sanctum')->guest()) return "Фамилия";
        return $value;
    }

    /*public function getCityAttribute($value)
    {
        if ($this->isEmployee() && $company = $this->company) {
            $boss = $company->boss;
            if ($boss) {
                return $boss->city;
            }
        }
        return $value;
    }*/

    public function getGeoCityIdAttribute($value)
    {
        if ($this->isEmployee() && $company = $this->company) {
            $boss = $company->boss;
            if ($boss) {
                return $boss->geo_city_id;
            }
        }
        return $value;
    }

    public function getCommentAttribute($value)
    {
        if (auth("sanctum")->guest()) {
            return null;
        }

        $user = auth('sanctum')->user();
        if ($user->isUser()) {
            return null;
        }
        return $value;
    }

    public function getAllowedToShowContactsAttribute(): bool
    {
        return $this->allowedToShowContacts();
    }

    /**
     *  Methods
     */

    public function isTestMode(): bool
    {
        $phone = $this->attributes['phone'];
        $env = config('app.env');
        $isReserved = in_array($phone, self::RESERVED_PHONES);
        $isTestMode = $env !== 'production' || $isReserved;
        
        Log::info("isTestMode check", [
            'phone' => $phone,
            'env' => $env,
            'is_reserved' => $isReserved,
            'result' => $isTestMode
        ]);
        
        return $isTestMode;
    }

    public function sendPhoneCode(): array
    {
        if ($this->isTestMode()) {
            $this->phone_code = 123456;
        } else {
            $this->phone_code = random_int(100000, 999999);
        }
        $this->phone_code_sent_at = Carbon::now();
        $this->save();

        return $this->sendSMS("Код для входа на сайт: $this->phone_code");
    }

    public function sendSMS(string $msg): array
    {
        if ($this->isTestMode()){
            return ['success' => true, 'message' => 'Сообщение не было отправлено, тестовый режим'];
        }
        
        $originalPhone = $this->attributes['phone'];
        $sms = new SMSRU(config("services.smsru.key"));
        $post = (object)[
            'to' => $originalPhone,
            'msg' => $msg,
            // 'from' => config("app.name"), // Раскомментировать после регистрации отправителя в SMS.RU
            'test' => $this->isTestMode(),
        ];
        Log::info("SMS отправка", ['phone' => $originalPhone, 'test_mode' => $this->isTestMode()]);
        $sent = $sms->send_one($post);
        Log::info("SMS результат", ['status' => $sent->status ?? 'unknown', 'status_text' => $sent->status_text ?? '']);

        if ($sent->status === "OK") {
            return ['success' => true, 'message' => 'Сообщение было отправлено'];
        }
        return ['success' => false, 'message' => $sent->status_text];
    }

    public function inSendingPhoneCodeTimeout(): bool
    {
        if ($this->isTestMode()) return false;
        return $this->phone_code_sent_at && Carbon::now()->diffInSeconds(Carbon::parse($this->phone_code_sent_at)) < self::PHONE_CODE_SENDING_TIMEOUT;
    }

    public function generateAccessToken(string $name): string
    {
        //$this->tokens()->delete();
        return $this->createToken($name)->plainTextToken;
    }

    public function verifyPhone(): void
    {
        if (!$this->phone_verified_at) {
            $this->phone_verified_at = Carbon::now();
            $this->save();
        }
    }

    public function resetEmailVerification()
    {
        $this->email_verified_at = null;
    }

    public function resetPhoneVerification()
    {
        $this->phone_verified_at = null;
    }

    public function isBoss(): bool
    {
        return $this->company && $this->company_role === self::COMPANY_ROLES[1];
    }

    public function isEmployee(): bool
    {
        return $this->company_role === self::COMPANY_ROLES[0];
    }

    public function isAdmin(): bool
    {
        return $this->type === self::USER_TYPES[2];
    }

    public function isModerator(): bool
    {
        return $this->type === self::USER_TYPES[1];
    }

    public function isUser(): bool
    {
        return $this->type === self::USER_TYPES[0];
    }

    public function profileCompleted(): bool
    {
        return $this->name && $this->email_verified_at && $this->phone_verified_at;
    }

    public function allowedToShowContacts(): bool
    {
        return $this->isAdmin() || $this->isModerator() || $this->profileCompleted() || Carbon::now()->diffInDays(Carbon::parse($this->created_at)) <= self::ANONYMOUS_CONTACTS_ACCESS_DAYS;
    }

    public function markAsOnline()
    {
        $this->last_online_datetime = Carbon::now();
        $this->save();
    }

    public function inFavorite(): bool
    {
        if (auth('sanctum')->guest()) return false;
        return FavoriteUser::query()->where("user_id", auth('sanctum')->id())
            ->where("target_user_id", $this->id)
            ->exists();
    }

    public function removeFromFavorite(): bool
    {
        FavoriteUser::query()->where("user_id", auth()->id())
            ->where("target_user_id", $this->id)
            ->delete();
        return false;

    }

    public function addToFavorite(): bool
    {
        $this->removeFromFavorite();
        FavoriteUser::query()->insert([
            'user_id' => auth()->id(),
            'target_user_id' => $this->id,
        ]);
        return true;
    }

    public function getEmailConfirmationHash(): string
    {
        return Hash::make($this->email_code);
    }

    public function verifyEmailConfirmationHash(string $hash): bool
    {
        return Hash::check($this->email_code, $hash);
    }

    public function sendEmailInvitation()
    {
        try {
            Mail::to($this)->send(new EmployeeInvitation($this));
        } catch (\Exception $exception) {

        }
    }

    public function getEmailResetLink(): string
    {
        $baseUrl = config("app.url");
        $resetHash = Hash::make($this->reset_hash);
        $originalEmail = $this->attributes['email'];
        $query = http_build_query([
            "hash" => $resetHash,
            "email" => $originalEmail,
        ]);;
        return "$baseUrl/auth/set-password?$query";
    }

    public function validateEmailResetLink(string $hash): bool
    {
        return Hash::check($this->reset_hash, $hash);
    }

    /**
     * @param $moveUid - ID сотрудника, которому передаём дела
     * @return void
     */
    public function prepareDeleting($moveUid = null): void
    {
        $user = $this;

        if ($user->company_id) {
            if ($user->isBoss()) {
                $user->orders->each(function (Order $order) {
                    $order->delete();
                });
                $user->company->delete();
            } else {
                $boss = $user->company->boss;
                $user->orders->each(function (Order $order) use ($boss, $moveUid) {
                    $order->user_id = $moveUid ?: $boss->id;
                    $order->save();
                });
            }
        } else {
            $user->orders->each(function (Order $order) {
                $order->delete();
            });
        }
    }

    public function countBadges(): array
    {
        $outReports = Message::getOutReportsNewMessagesCount($this);
        $inReports = Message::getInReportsNewMessagesCount($this);
        $orderNewMessages = Message::orderNewMessagesCount($this);
        $reports = $outReports + $inReports;
        $notifications = CompanyNotification::query()->visible($this)->new()->count();
        $recommendations = Recommendation::query()->forUser($this)->approved()->new()->count();
        $count = $reports + $notifications + $recommendations + $orderNewMessages;
        return [
            'reports_badges_value' => $reports,
            'unresolved_reports_badges_value' => $outReports,
            'to_me_reports_badges_value' => $inReports,
            'notifications_badges_value' => $notifications,
            'recommendations_badges_value' => $recommendations,
            'total_count' => $count,
            'messages_count' => $orderNewMessages
        ];
    }

    public function getSilenceDelay(): int
    {
        if (!$this->silence) return 0; // silence disabled -> no delay
        $now = Carbon::now();
        $startSilence = Carbon::now()->setHour($this->silence_from)->setMinute($this->silence_from_m)->startOfMinute();
        $endSilence = Carbon::now()->setHour($this->silence_to)->setMinute($this->silence_to_m)->endOfMinute();
        if ($now->isBetween($startSilence, $endSilence)) {
            // calc delay to end silence
            return $endSilence->diffInSeconds($now);
        }

        return 0;
    }
}
